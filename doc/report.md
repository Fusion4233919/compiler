# 编译原理课程设计报告

曾俊浩 贺情怡 范安东

## 1 语言

### 1.1 语言描述
[TODO]
#### BNF
[TODO]
#### 语言特性
[TODO]

### 1.2 词法
主要使用lex工具完成编译器的词法分析工作，具体代码见scanner.l
即把字符串转换成为相应的token

#### 变量名
我们的语言中对变量名的规定如下：
- 函数类型变量名（包括函数名）以字符'_'开始，后面为至少一个字母
- 其余类型变量名由至少一个字母构成

#### 运算符
我们的语言将以下符号识别为运算符：
- 逻辑运算符： || && == <= >= != < >
- 算术运算符： + - * / %
- 赋值运算符： =

#### 关键字
我们的语言中定义了如下关键字：
- 类型：int void function fn
- 流程控制： if loop break continue return
- 代码组成： do done declare
- 标准函数: _input _output

#### 注释
我们的语言采用类C的注释风格 /* this is a comment */

使用正则表达式"/*"([^\*]|(\*)*[^\*/])*(\*)*"*/"来识别注释

#### 数字、字符和字符串
我们的语言支持整数常量、字符常量，可以识别一个整数、由一对单引号包裹的单个字符、由一对单引号包裹的转义字符作为int类型的常量

字符将会以ASCII码的方式以整数形式存储，包括'\t', '\n'等转义字符

我们的语言暂未支持整个字符串的操作，但是依旧可以使用正则表达式\"(\\.|[^"\\])*\"来识别由一对双引号包裹的0个或多个字符、转义字符的序列作为一个字符串常量

### 1.3 语法与解析树（parse tree）
主要使用yacc工具完成编译器的语法分析工作，具体代码见parser.y
即把token转换成为对应的语法树节点，并建立一棵解析树

整个程序语言由以下模块组成，每个模块中有若干条相应语句
```
|- Program
   |- Def_List
   |  |- Def
   |
   |- Fun_Def_List
      |- Fun_Def
         |- Def_List
         |- Exp_List
```

#### 解析树
每个程序在编译过程中都会依照语法定义生成一颗解析树，
解析树的每个节点中主要存储以下信息：
- 节点ID：用于可视化时识别节点
- 节点类型：主要分为列表类节点与普通节点
- 子节点列表：用于存储该节点的下属节点
- 节点参数：名称、数据类型、运算符类型等

列表类节点的典型代表为变量定义列表（Def_List）
```
Def_List        : Def_List Def ';' {$$=$1; $$->Insert($2);}
                | {$$=new AST(Type::list, "Def_List");}
                ;
```
该类节点拥有若干个相同类型的孩子，如变量声明、函数参数传递、语句块等等

普通节点拥有固定数量的孩子，每个孩子所表达的含义也早已约定好，
如条件语句节点（If_Stmt）
```
If_Stmt         : IF '(' Cond_Exp ')' DO Exp_List DONE {$$=new AST(Type::expr, "If_Stmt"); $$->Insert($3); $$->Insert($6);}
                ;
```
该节点共有两个孩子，一个为条件语句，另一个为待执行语句块


### 1.4 语义与符号表
主要使用两次遍历来完成对代码语义的检测工作，具体代码见AST.cpp
#### 变量表与函数表
每个函数拥有一张变量表和一张函数表，另外还有一张全局变量表和一张全局函数表

变量表中存储以下信息：
- 变量名：唯一字段，用于在同一作用域中唯一确定一个变量
- 变量数据类型：表示变量的类型，同时用于传递错误
- 变量归属：用于表示变量的作用域
- 变量维度：用于向量型变量，存储维度

函数表中存储以下信息：
- 函数名：唯一字段，用于在同一作用域中唯一确定一个函数
- 函数返回类型：表示函数返回值的类型，同时用于传递错误
- 函数参数表：存储函数参数的数据类型与名称
- 函数归属：用于表示函数的作用域
- 下属变量表与函数表：用于查找定义在该函数内的变量与函数
- 父函数变量表：用于查找定义于该函数同级的变量

#### 语义检查
首先对解析树进行先序遍历，根据节点类型（主要是定义类型节点）和节点数据建立若干张变量表与函数表；
生成符号表中各项的类型、作用域等，在此过程中也会检测是否有变量、函数的重复定义

第二次遍历则是根据已生成的符号表，检测变量、函数的使用是否符合类型要求

这两次遍历完成了对代码语义的审查，可以认为通过了语义检查的代码是完全符合语言要求的

## 2 中间代码生成

fad

## 3 进阶主题

### 3.1 错误提示
编译错误时如果没有提示，需要从整个代码里寻找错误之处，一个好的编译器需要能提示编译错误出现的地点，更好的则是提出改正的方式，所以错误提示对于一个编译器是十分重要，甚至是必备的

错误提示在词法检测、语法检测、语义检测中均有出现：
#### 词法错误
词法错误提示在词法分析时给出；
词法错误的原因一般是出现了不能识别的字符串，不能被归类于任何一种token；此时会提示出现错误的行号
#### 语法错误
语法错误提示在生成解析树时给出；
语法错误的原因大多没有按照语法规则进行代码书写，如关键字错误；此时会提示出现错误的行号与出错的文本
#### 语义错误
语义错误提示在生成符号表或利用符号表检查代码时给出；
语义错误的种类多样，主要包括运算符类型不匹配、函数参数类型不匹配等；此时会给出提示出现错误的类型
### 3.2 简易函数式编程

fad

## 4 测试与结果

### 4.1 快速排序

#### 4.1.1 要求

##### 输入

第一行输入一个整数N，接下来N行每行输入一个整数$x_i$，保证$-10^4<x_i<10^4$，不保证两两不等。

##### 输出

将这N个整数从小到大排序后输出，每个数独占一行。排序算法必须使用递归形式的快速排序完成。

#### 4.1.2 结果

### 4.2 矩阵乘法

#### 4.2.1 要求

##### 输入

输入两个矩阵A和B，每个矩阵第一行是两个整数M和N，分别代表行数和列数，接下来M行，每行N个整数，代表矩阵的数据。不保证A和B可以进行乘法操作。

##### 输出

如果A和B不能相乘，输出提示，否则输出进行乘法运算后得到的结果矩阵，每个元素占10位。

#### 4.2.2 结果

### 4.3 选课助手

#### 4.3.1 要求

##### 输入

输入一个培养方案，每行代表一门课程，空行代表输入结束。

每个课程由课程名称，学分，前置课程和成绩四个元素组成，每个元素用'|'分隔。

1. 课程名称是由数字和大小写字母组成的长度不为0的字符串
2. 学分是非负整数（可以为0）
3. 前置课程是修读本门课程时必须已经获得学分的课程。由若干课程集合组成，每个集合用';'分隔；课程集合由若干课程组成，由','分隔。只要完成了任一课程集合内的所有课程 的修读，即可修读本门课程。
4. 成绩只有A, B, C, D, F或为空六个选项。ABCD分别对应4，3，2，1的四分制成绩，F代表未通过考核，不算完成该课程的修读，但以0分算入GPA计算；该字串为空则表明尚未尝试修读该课程

##### 输出

依次输出GPA，尝试修读的学分（包括F成绩的课程），已获得学分（不包括F课程），剩余学分（培养方案中剩余未修读的学分数，包括F课程），推荐课程（满足前置课程条件，可以修读的课程，包括成绩F的课程，按照输入的先后顺序输出）

#### 4.3.2 结果